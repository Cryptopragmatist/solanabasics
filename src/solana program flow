The flow of a program using this structure looks like this:

1.  Someone calls the entrypoint
2. The entrypoint forwards the arguments to the processor
3. The processor asks instruction.rs to decode the instruction_data
 argument from the entrypoint function.
4. Using the decoded data, the processor will now decide
 which processing function to use to process the request.
5. The processor may use state.rs to encode state into or decode
 the state of an account which has been passed into the entrypoint.

 lib.rs -> registering modules
 entrypoint.rs -> entrypoint to the program
 instruction.rs -> program API, (de)serializing instruction data
 processor.rs -> program logic 
 state.rs -> program objects, (de)serializing state 
 error.rs -> program specific errors

 The analogy is that the customer(caller) calls the frontdesk(entrypoint) then it forwards the request to Mr.Processor. Mr.Processor will then
 consult the manual(instruction.rs) to interpret(decode) the request.After decoding, Mr.Processor will decide what processing function
 to use to execute the request. Mr processor can use editor (state.rs ) to alter the state of the account.